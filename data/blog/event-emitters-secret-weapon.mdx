---
title: 'Build Your Own Event Emitter'
date: '2023-09-10'
tags: ['javascript', 'typescript', 'design-patterns', 'architecture']
draft: false
authors: ['default']
summary: Discover how event emitters can elegantly decouple your components and create more maintainable codebases with this practical TypeScript implementation
---

![event-emitters](/static/blogs/build-your-own-event-emitters/banner.jpg)

## Introduction

As someone who loves building software, I'm always looking for patterns that make my code cleaner, more modular, and easier to maintain. One of the most powerful tools I've discovered? **Event emitters.**

At first, I used them without really understanding how they workedâ€”just copying snippets from libraries or frameworks. But when I finally took the time to dig deeper, everything clicked. Event emitters became my go-to solution for managing communication between different parts of an application without creating messy dependencies.

## Understanding Event Emitters

An event emitter is essentially a pub-sub (publish-subscribe) system where:

- Components can **subscribe** to events
- Other components can **emit** those events
- The emitter handles notifying all subscribers

This creates beautiful decoupling between different parts of your application.

## Building Our Own Event Emitter

Let's implement a type-safe event emitter in TypeScript:

```typescript
// generic type representing all possible events our emitter can handle.
type EventMap = Record<string, any>

class EventEmitter<T extends EventMap> {
  private listeners: {
    // Each key is an event name, and the value is an array of callbacks
    [K in keyof T]?: Array<(payload: T[K]) => void>
  } = {}

  // Subscribe to an event
  // `on` method takes an event name and a callback function as arguments.
  on<K extends keyof T>(event: K, callback: (payload: T[K]) => void) {
    if (!this.listeners[event]) {
      this.listeners[event] = []
    }
    this.listeners[event]?.push(callback)

    // Return unsubscribe function
    return () => {
      this.off(event, callback)
    }
  }

  // Unsubscribe from an event
  off<K extends keyof T>(event: K, callback: (payload: T[K]) => void) {
    const callbacks = this.listeners[event]
    if (!callbacks) return

    this.listeners[event] = callbacks.filter((cb) => cb !== callback)
  }

  // Emit an event (notify all listeners)
  emit<K extends keyof T>(event: K, payload: T[K]) {
    const callbacks = this.listeners[event]
    if (!callbacks) return

    callbacks.forEach((callback) => callback(payload))
  }

  // One-time listener
  once<K extends keyof T>(event: K, callback: (payload: T[K]) => void) {
    const onceWrapper = (payload: T[K]) => {
      callback(payload)
      this.off(event, onceWrapper)
    }
    this.on(event, onceWrapper)
  }
}
```

## How i have used Event Emitters

### 1. UI Component Communication

```typescript
// Define our events
type ButtonEvents = {
  click: { x: number; y: number }
  hover: boolean
}

class Button {
  private emitter = new EventEmitter<ButtonEvents>()

  constructor(private element: HTMLElement) {
    element.addEventListener('click', (e) => {
      this.emitter.emit('click', {
        x: e.clientX,
        y: e.clientY,
      })
    })

    element.addEventListener('mouseenter', () => {
      this.emitter.emit('hover', true)
    })

    element.addEventListener('mouseleave', () => {
      this.emitter.emit('hover', false)
    })
  }

  onClick(callback: (pos: { x: number; y: number }) => void) {
    return this.emitter.on('click', callback)
  }

  onHover(callback: (isHovering: boolean) => void) {
    return this.emitter.on('hover', callback)
  }
}

// Usage
const button = new Button(document.getElementById('my-btn'))
const unsubscribe = button.onClick(({ x, y }) => {
  console.log(`Clicked at (${x}, ${y})`)
})

unsubscribe() // Clean it up (I made this mistake a lot)
```

### 2. State Management (My Favorite Use Case)

```typescript
type StoreEvents<T> = {
  change: T
  error: string
}

class SimpleStore<T> {
  private emitter = new EventEmitter<StoreEvents<T>>()
  private state: T

  constructor(initialState: T) {
    this.state = initialState
  }

  setState(newState: T) {
    this.state = newState
    this.emitter.emit('change', newState)
  }

  subscribe(callback: (state: T) => void) {
    return this.emitter.on('change', callback)
  }
}

// Usage
const store = new SimpleStore({ count: 0 })
store.subscribe((state) => {
  console.log('New state:', state)
})

store.setState({ count: 1 }) // Logs: "New state: { count: 1 }"
```

## Why I Love This Pattern

1. **Decoupling**: Components don't need to know about each other
2. **Flexibility**: Easy to add new listeners without modifying existing code
3. **Type Safety**: TypeScript prevents common mistakes
4. **Performance**: Lightweight compared to many alternatives
5. **Debugging**: Easy to track event flow through the system

## Common Pitfalls to Avoid

| Pitfall          | Solution                                     |
| ---------------- | -------------------------------------------- |
| Memory Leaks     | Always unsubscribe when components unmount   |
| Too Many Events  | Keep your event types focused and meaningful |
| Complex Payloads | Keep event data simple and structured        |

## Nice Practices i picked up along the way

1. **Clean up subscriptions** to prevent memory leaks:

   ```typescript
   // React example
   useEffect(() => {
     const unsubscribe = emitter.on('event', handler)
     return () => unsubscribe()
   }, [])
   ```

2. **Use TypeScript** to make your events self-documenting (battery included!)

3. **Keep events focused** on specific actions or state changes

4. **Document your event system** for team members

## Conclusion

Event emitters have become one of my most trusted tools for building maintainable software. They're particularly useful when:

- You need communication between decoupled components
- You want to avoid complex dependency chains
- You need a flexible system that can evolve over time

The TypeScript implementation we built provides excellent type safety while remaining lightweight and flexible. I encourage you to try building your own event emitter and see where it might simplify your codebase!

```typescript
// Simple usage example to end with
const emitter = new EventEmitter<{
  greeting: string
}>()

emitter.on('greeting', (name) => {
  console.log(`Hello, ${name}!`)
})

emitter.emit('greeting', 'TypeScript') // "Hello, TypeScript!"
```
